[
    {
        "question": "Implement an algorithm to determine if a \nstring has all unique characters.  What if \nyou can not use additional data structures?",
        "answer": "For simplicity, assume char set is ASCII (if not, we need to increase the storage size.  The rest \nof the logic would be the same). \nNOTE\n: This is a \ngreat\n thing to point out to your interviewer!\n1 public static boolean isUniqueChars2(String str) {\n2  boolean[] char_set = new boolean[256];\n3  for (int i = 0; i < str.length(); i++) {\n4   int val = str.charAt(i);\n5   if (char_set[val]) return false;\n6   char_set[val] = true;\n7  }\n8  return true;\n9 }\nTime complexity is O(n), where n is the length of the string, and space complexity is O(n).\nWe can reduce our space usage a little bit by using a \nbit vector.  We will assume, in the below \ncode, that the string is only lower case ‚a’ through ‚z’.  This will allow us to use just a single int\n1 public static boolean isUniqueChars(String str) {\n2  int checker = 0;\n3  for (int i = 0; i < str.length(); ++i) {\n4   int val = str.charAt(i) - ‚a’;\n5   if ((checker & (1 << val)) > 0) return false;\n6   checker \n7  }\n8  return true;\n9 }\nAlternatively, we could do the following:\n1.  Check every char of the string with every other char of the string for duplicate occur-rences. This will take \nO(n^2) time and no space.\n2.  If we are allowed to destroy the input string, we could sort the string in O(n log n) time \nand then linearly check the string for neighboring characters that are identical.  Care-ful, though - many sorting algorithms take up extra space."
    }
]